---
bg: "opencv.png"
layout: post
comments: true
title: "C# OpenCV 강좌 : 제 61강 - 내부 채우기"
crawlertitle: "C# OpenCV 강좌 : 제 61강 - 내부 채우기"
summary: "C# OpenCV Flood Fill"
date: 2018-10-13
categories: posts
tags: ['C#-OpenCvSharp2']
author: 윤대희
---

### 내부 채우기 (Flood Fill) ###
----------
[![1]({{ site.images }}/C/opencv/ch61/1.png)]({{ site.images }}/C/opencv/ch61/1.png)
영상이나 이미지에서 지정된 색으로 연결된 객체의 `내부`를 채우는데 사용합니다.

<br>

`영상 사용하기` : [3강 바로가기][3강]
<br>
`이미지 사용하기` : [4강 바로가기][4강]

<br>

### Main Code ###
----------
{% highlight C# %}

using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using OpenCvSharp;

namespace test
{
    class OpenCV : IDisposable
    {
        IplImage fill;

        public IplImage FloodFill(IplImage src)
        {
            fill = new IplImage(src.Size, BitDepth.U8, 3);
            fill = src.Clone();

            CvWindow win = new CvWindow("Window", WindowMode.StretchImage, fill);
            CvPoint Pt = new CvPoint(-1, -1);
            CvConnectedComp Comp = new CvConnectedComp();

            win.OnMouseCallback += delegate (MouseEvent eve, int x, int y, MouseEvent flag)
            {
                if (eve == MouseEvent.LButtonDown)
                {
                    Pt = new CvPoint(x, y);
                    Cv.FloodFill(fill, Pt, CvColor.Black, Cv.ScalarAll(50), Cv.ScalarAll(50), out Comp, FloodFillFlag.Link8);
                    win.ShowImage(fill);
                    Console.WriteLine(Comp.Area);                
                }
                else if (eve == MouseEvent.RButtonDown)
                {
                    Pt = new CvPoint(x, y);
                    Cv.FloodFill(fill, Pt, CvColor.White, Cv.ScalarAll(50), Cv.ScalarAll(50), out Comp, FloodFillFlag.Link8);
                    win.ShowImage(fill);
                    Console.WriteLine(Comp.Area);                
                }
            };

            while(true)
            {
                int key = Cv.WaitKey(0);
                if (key == 'r')
                {
                    fill = src.Clone();
                    win.ShowImage(fill);
                }
                else if(key == 'q')
                {
                    Cv.DestroyAllWindows();
                    break;
                }
            }    
            return fill;
        }
            
        public void Dispose()
        {
            if (fill != null) Cv.ReleaseImage(fill);   
        }
    }
}

{% endhighlight %}

<br>

### Class Code ###
----------

{% highlight C# %}

fill = new IplImage(src.Size, BitDepth.U8, 3);
fill = src.Clone();

{% endhighlight %}

`fill`은 원본을 복사한 이미지입니다. 

`fill`에 `src`를 복제하여 같은 이미지로 변경합니다.

<br>

{% highlight C# %}

CvWindow win = new CvWindow("Window", WindowMode.StretchImage, fill);
CvPoint Pt = new CvPoint(-1, -1);
CvConnectedComp Comp = new CvConnectedComp();

{% endhighlight %}

윈도우 창 `win`을 생성하고 초기 이미지를 `fill`로 사용합니다.

마우스 포인터의 위치로 사용할 `Pt`를 `-1, -1`의 좌표로 초기화합니다.

함수를 구조화하기위한 포인터인 `Comp`를 생성합니다.

<br>

* Tip : `Comp`에 내부 채우기를 실행했을 때 생성되는 **정보**가 담겨있습니다.

<br>

{% highlight C# %}

win.OnMouseCallback += delegate (MouseEvent eve, int x, int y, MouseEvent flag)
{
    if (eve == MouseEvent.LButtonDown)
    {
        ...
    }
    else if (eve == MouseEvent.RButtonDown)
    {
        ...
    }
};

{% endhighlight %}

`마우스 콜백 이벤트`를 `delegate` 형식으로 적용하여 `클래스` 내부에서도 함수가 작동하게 생성합니다.

<br>

{% highlight C# %}

if (eve == MouseEvent.LButtonDown)
{
    Pt = new CvPoint(x, y);
    Cv.FloodFill(fill, Pt, CvColor.Black, Cv.ScalarAll(50), Cv.ScalarAll(50), out Comp, FloodFillFlag.Link8);
    win.ShowImage(fill);
    Console.WriteLine(Comp.Area);
}
else if (eve == MouseEvent.RButtonDown)
{
    Pt = new CvPoint(x, y);
    Cv.FloodFill(fill, Pt, CvColor.White, Cv.ScalarAll(50), Cv.ScalarAll(50), out Comp, FloodFillFlag.Link8);
    win.ShowImage(fill);
    Console.WriteLine(Comp.Area);
}

{% endhighlight %}

`Pt`에 현재 마우스 좌표를 저장합니다.

`Cv.FloodFill()`를 이용하여 **내부 채우기**를 실행합니다. `Cv.FloodFill(계산 이미지, 내부 채우기 색상, 하한 값, 상한 값, 연결 요소, 연결성)`입니다.

`하한 값`은 `Pt` 위치에서의 **(해당 색상 값 - 하한 값)**의 색상까지는 같은 색상으로 간주합니다.

`상한 값`은 `Pt` 위치에서의 **(해당 색상 값 + 상한 값)**의 색상까지는 같은 색상으로 간주합니다.

`연결 요소`는 내부 채우기를 실행하였을 때의 **정보**가 담겨있습니다.

`연결성`은 픽셀의 어떠한 **이웃 값**이 고려될지를 설정합니다.

<br>

* `FloodFillFlag.*`
    * `Link4` : 이웃한 4 픽셀을 고려합니다.
    * `Link8` : 이웃한 8 픽셀을 고려합니다.
    * `FixedRange` : 시드 픽셀간의 차이를 고려합니다.
    * `MaskOnly` : 이미지를 변경하지 않고, 마스크를 채웁니다.

<br>

 * Tip : `마스크`의 파라미터는 `연결성` 파라미터 이후에 콤마 (,)를 추가하여 값을 할당할 수 있습니다.

<br>

{% highlight C# %}

while(true)
{
    int key = Cv.WaitKey(0);
    if (key == 'r')
    {
        fill = src.Clone();
        win.ShowImage(fill);
    }
    else if(key == 'q')
    {
        Cv.DestroyAllWindows();
        break;
    }
}

{% endhighlight %}

`키 이벤트`를 사용하여 `r`키가 눌러졌을 때, 이미지를 초기화하며 `q`키가 눌러졌을 때, 종료합니다.

<br>

### Result ###
----------
[![2]({{ site.images }}/C/opencv/ch61/2.png)]({{ site.images }}/C/opencv/ch61/2.png)

[3강]: https://076923.github.io/posts/C-opencv-3/
[4강]: https://076923.github.io/posts/C-opencv-4/


