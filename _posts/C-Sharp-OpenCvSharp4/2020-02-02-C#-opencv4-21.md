---
layout: post
title: "C# OpenCV 강좌 : 제 21강 - 아핀 변환"
tagline: "C# OpenCV4 Affine Transformation"
image: /assets/images/opencv.png
header:
  image: /assets/patterns/asanoha-400px.png
tags: ["OpenCvSharp4"]
keywords: C#, Visual Studio, OpenCV, OpenCvSharp4, OpenCvSharp4 Affine Transformation, OpenCvSharp4 GetRotationMatrix2D, OpenCvSharp4 GetAffineTransform, OpenCvSharp4 WarpAffine
ref: C#-OpenCvSharp4
category: C#
permalink: /posts/C-opencv4-21/
comments: true
toc: true
---

## 아핀 변환(Affine Transformation)

![1]({{ site.images }}/assets/posts/C-Sharp/OpenCvSharp4/lecture-21/1.webp){:class="lazyload" width="100%" height="100%"}

`아핀 변환(Affine Transformation)`은 **선형 변환**에 **이동 변환**까지 포함된 변환입니다.

선의 수평성을 유지하며, 변환 전의 서로 평행한 선은 변환 후에도 평행함을 의미합니다.

즉, **길이의 비**와 **평행성**이 `보존`되는 변환입니다. `사각형을 평행사변형으로 변환`하는 것을 `아핀 변환`으로 간주합니다.

<br>
<br>

## 아핀 변환 행렬(Affine Transformation Matrix)

![2]({{ site.images }}/assets/posts/C-Sharp/OpenCvSharp4/lecture-21/2.webp){:class="lazyload" width="100%" height="100%"}

아핀 변환 행렬의 기본형은 `3×3 행렬`이지만 세 번째 행의 값은 `0, 0, 1`의 값을 지닙니다.

좌변의 행렬과 우변의 행렬의 **세 번째 행의 값은 항상 같은 값**을 지니게 되어 OpenCV에서는 2×3 행렬로 표현합니다.

행렬의 $$ x_1 $$, $$ y_1 $$은 변환 전 **원본 이미지의 픽셀 좌표**를 의미하며, $$ x_2 $$, $$ y_2 $$는 **변환 후의 결과 이미지의 픽셀 좌표**를 의미합니다.

변환 후의 픽셀 좌표를 계산하기 위해서는 미지수 $$ a_{00} $$, $$ a_{01} $$, $$ a_{10} $$, $$ a_{11} $$, $$ b_0 $$, $$ b_1 $$의 값을 알아야 합니다.

**여섯 개의 미지수**를 구하기 위해 **세 개의 좌표**를 활용해 미지수를 계산합니다. 

<br>
<br>

## 메인 코드

{% highlight c# %}

using System;
using OpenCvSharp;
using System.Collections.Generic;

namespace Project
{
    class Program
    {
        static void Main(string[] args)
        {
            Mat src = new Mat("snow.jpg");
            Mat dst = new Mat();

            List<Point2f> src_pts = new List<Point2f>()
            {
                new Point2f(0.0f, 0.0f),
                new Point2f(0.0f, src.Height),
                new Point2f(src.Width, src.Height)
            };

            List<Point2f> dst_pts = new List<Point2f>()
            {
               new Point2f(300.0f, 300.0f),
               new Point2f(300.0f, src.Height),
               new Point2f(src.Width - 400.0f, src.Height - 200.0f)
            };

            Mat matrix = Cv2.GetAffineTransform(src_pts, dst_pts);
            Cv2.WarpAffine(src, dst, matrix, new Size(src.Width, src.Height));

            Cv2.ImShow("dst", dst);
            Cv2.WaitKey(0);
        }   
    }
}

{% endhighlight %}

<br>

### 세부 코드

{% highlight c# %}

Mat src = new Mat("snow.jpg");
Mat dst = new Mat();

{% endhighlight %}

`new Mat`을 사용해 이미지를 `src`에 할당합니다.

연산 결과를 저장할 `dst`를 선언합니다.

<br>

{% highlight c# %}

List<Point2f> src_pts = new List<Point2f>()
{
    new Point2f(0.0f, 0.0f),
    new Point2f(0.0f, src.Height),
    new Point2f(src.Width, src.Height)
};

List<Point2f> dst_pts = new List<Point2f>()
{
    new Point2f(300.0f, 300.0f),
    new Point2f(300.0f, src.Height),
    new Point2f(src.Width - 400.0f, src.Height - 200.0f)
};

Mat matrix = Cv2.GetAffineTransform(src_pts, dst_pts);

{% endhighlight %}

아핀 변환을 진행하기 위해선, 아핀 맵 행렬을 생성해야 합니다.

`아핀 맵 행렬 생성 함수(Cv2.GetAffineTransform)`는 `변환 전 세 개의 픽셀 좌표(src_pts)`와 `변환 후 세 개의 픽셀 좌표(dst_pts)`를 이용해 `아핀 맵 행렬(matrix)`을 생성합니다.

`Cv2.GetAffineTransform(변환 전 픽셀 좌표, 변환 후 픽셀 좌표)`로 `아핀 맵 행렬`을 생성합니다.

`픽셀 좌표`는 **3개**의 픽셀 좌표를 포함해야 하므로, `목록(List)`을 통해, `Point2f` 형식의 좌표를 생성합니다.

`src_pts`와 `dst_pts`의 픽셀 좌표들의 순서는 **1:1**로 매칭됩니다.

<br>

{% highlight c# %}

Cv2.WarpAffine(src, dst, matrix, new Size(src.Width, src.Height));

{% endhighlight %}

생성된 아핀 행렬을 활용해 `아핀 변환`을 진행합니다.

`아핀 변환 함수(Cv2.WarpAffine)`는 아핀 행렬을 사용해 변환된 이미지를 생성합니다.

`Cv2.WarpAffine(원본 배열, 결과 배열, 행렬, 결과 배열의 크기, 보간법, 테두리 외삽법, 테두리 색상)`로 아핀 변환을 진행합니다.

`결과 배열의 크기`를 설정하는 이유는 회전 후, **원본 배열의 이미지 크기와 다를 수 있기 때문입니다.**

이미지를 더 큰 공간에 포함하거나, 더 작은 공간에 포함할 수 있습니다.

그러므로, `결과 배열`의 크기를 새로 할당하거나, `원본 배열`의 크기와 동일하게 사용합니다.

`보간법`, `테두리 외삽법`, `테두리 색상` 또한, 새로운 공간에 이미지를 할당하므로, 보간에 필요한 매개변수들을 활용할 수 있습니다.

<br>
<br>

## 출력 결과

![3]({{ site.images }}/assets/posts/C-Sharp/OpenCvSharp4/lecture-21/3.webp){:class="lazyload" width="100%" height="100%"}
